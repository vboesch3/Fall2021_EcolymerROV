/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/
#ifndef __CPP_BVTNAVDATA_H__
#define __CPP_BVTNAVDATA_H__

#include <string>
#include <bvt_cpp/bvt_retval.h>
#include <bvt_cpp/bvt_navdata.h>

namespace BVTSDK
{

/** NavData contains various types of user-accessible navigation parameter, which
 * can be saved to and retrieved from a sonar file on a per ping basis.
 * The NavData objects can be created and destroyed as needed. When the
 * ping functions are called to get or put the data, the data is copied.
 * This allows NavData objects to be pre-allocated and filled from various
 * instrument sources. It also allows the data to be copied from one
 * NavData object to the other.
 * NOTE: NavData changes will only be saved to a sonar of type FILE. 
 */
class NavData
{
public:
	/// Create the object
	NavData()
	{ m_ptr = BVTNavData_Create(); }

	/// Destroy the object
	~NavData()
	{ BVTNavData_Destroy(m_ptr); }

#ifndef DOXY_IGNORE
	NavData(BVTNavData ptr)
	{ m_ptr = ptr; }

	operator BVTNavData()
	{ return m_ptr; }
	operator BVTNavData*()
	{ return &m_ptr; }
	operator const BVTNavData() const
	{ return m_ptr; }
#endif

	/** Clones the data from the passed NavData object to this object. Both objects
	 * must have already been created.
	 * \param navdata_to_clone existing NavData object to copy from 
	 */
	RetVal Clone(const NavData& navdata_to_clone)
	{
		return BVTNavData_Clone( m_ptr, navdata_to_clone );
	}

	/** Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
	 * \param degrees latitude in degrees 
	 */
	RetVal GetLatitude(double* degrees)
	{
		return BVTNavData_GetLatitude( m_ptr, degrees );
	}

	/** Stores the latitude, as a signed floating point number of degrees.
	 * Latitudes in the Western hemisphere are expressed as negative numbers.
	 * \param degrees latitude in degrees 
	 */
	RetVal SetLatitude(double degrees)
	{
		return BVTNavData_SetLatitude( m_ptr, degrees );
	}

	/** Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
	 * \param degrees longitude in degrees 
	 */
	RetVal GetLongitude(double* degrees)
	{
		return BVTNavData_GetLongitude( m_ptr, degrees );
	}

	/** Stores the longitude, as a signed floating point number of degrees.
	 * Longitudes in the Southern hemisphere are expressed as negative numbers.
	 * \param degrees longitude in degrees 
	 */
	RetVal SetLongitude(double degrees)
	{
		return BVTNavData_SetLongitude( m_ptr, degrees );
	}

	/** Returns the estimated horizontal error (see next function for details). 
	 * If none was stored, returns BVT_NAV_NO_DATA.
	 * \param error_meters potential error distance, in meters 
	 */
	RetVal GetHorizontalPrecisionError(float* error_meters)
	{
		return BVTNavData_GetHorizontalPrecisionError( m_ptr, error_meters );
	}

	/** Stores the estimated possible horizontal error. This is primarily (but not exclusively)
	 * intended for GPS systems, where there may be some doubt as to the
	 * quality of the position fix. HDOP is common, but not used here, as
	 * that is a unitless measure and varies between different manufacturers and models. <br>
	 * The idea is to use whatever calculations are appropriate for the 
	 * local navigation system, and store a possible error value in meters.
	 * Some GPS units will attempt to give this directly. (for example,
	 * the HPE field in the PGRME sentence, supplied by some Garmin units.)
	 * In the case of large errors, or old data, it may be best to either
	 * not store a position, or not store new data. (also consider using
	 * the NavData time parameter to store the time of last fix, which
	 * can then be compared to the ping time when the data is read back to
	 * determine the age of the GPS reading.)
	 * \param error_meters potential error distance, in meters 
	 */
	RetVal SetHorizontalPrecisionError(float error_meters)
	{
		return BVTNavData_SetHorizontalPrecisionError( m_ptr, error_meters );
	}

	/** Returns the height above mean sea level. If no value was stored for
	 * this ping, returns BVT_NAV_NO_DATA.
	 * \param meters_above_geoid height in floating point meters 
	 */
	RetVal GetHeight(float* meters_above_geoid)
	{
		return BVTNavData_GetHeight( m_ptr, meters_above_geoid );
	}

	/** Store the height above Mean Sea Level (usually the EGM96 geoid))
	 * \param meters_above_geoid altitude in floating point meters 
	 */
	RetVal SetHeight(float meters_above_geoid)
	{
		return BVTNavData_SetHeight( m_ptr, meters_above_geoid );
	}

	/** Returns the estimated vertical error (see next function for details). 
	 * If none was stored, returns BVT_NAV_NO_DATA.
	 * \param error_meters potential error distance, in meters 
	 */
	RetVal GetVerticalPrecisionError(float* error_meters)
	{
		return BVTNavData_GetVerticalPrecisionError( m_ptr, error_meters );
	}

	/** Stores the estimated possible vertical error (height) above 
	 * Mean Sea Level (EGM96 geoid).  For other notes, see the functions
	 * or Horizontal Precision Error, above.
	 * \param error_meters potential error distance, in meters 
	 */
	RetVal SetVerticalPrecisionError(float error_meters)
	{
		return BVTNavData_SetVerticalPrecisionError( m_ptr, error_meters );
	}

	/** Returns the depth. If no value was stored for this ping, returns
	 * BVT_NAV_NO_DATA.
	 * \param meters_below_surface depth in floating point meters 
	 */
	RetVal GetDepth(float* meters_below_surface)
	{
		return BVTNavData_GetDepth( m_ptr, meters_below_surface );
	}

	/** Store the depth.
	 * \param meters_below_surface depth in floating point meters 
	 */
	RetVal SetDepth(float meters_below_surface)
	{
		return BVTNavData_SetDepth( m_ptr, meters_below_surface );
	}

	/** Returns the altitude. If no value was stored for this ping, returns
	 * BVT_NAV_NO_DATA.
	 * \param meters_above_bottom altitude in floating point meters 
	 */
	RetVal GetAltitude(float* meters_above_bottom)
	{
		return BVTNavData_GetAltitude( m_ptr, meters_above_bottom );
	}

	/** Store the altitude.
	 * \param meters_above_bottom altitude in floating point meters 
	 */
	RetVal SetAltitude(float meters_above_bottom)
	{
		return BVTNavData_SetAltitude( m_ptr, meters_above_bottom );
	}

	/** Returns the heading relative to True North. If no value was stored
	 * for this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_true True heading, in degrees 
	 */
	RetVal GetHeading(float* degrees_true)
	{
		return BVTNavData_GetHeading( m_ptr, degrees_true );
	}

	/** Store the heading relative to True North.
	 * \param degrees_true True heading, in degrees 
	 */
	RetVal SetHeading(float degrees_true)
	{
		return BVTNavData_SetHeading( m_ptr, degrees_true );
	}

	/** Returns the velocity along the heading. If no value was stored
	 * for this ping, returns BVT_NAV_NO_DATA.
	 * \param meters_per_second velocity, in meters per second 
	 */
	RetVal GetHeadingVelocity(float* meters_per_second)
	{
		return BVTNavData_GetHeadingVelocity( m_ptr, meters_per_second );
	}

	/** Store the velocity along the heading.
	 * \param meters_per_second velocity, in meters per second 
	 */
	RetVal SetHeadingVelocity(float meters_per_second)
	{
		return BVTNavData_SetHeadingVelocity( m_ptr, meters_per_second );
	}

	/** Returns the course over ground (true). If no value was stored for
	 * this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_true course over ground, true, in degrees 
	 */
	RetVal GetCourseOverGround(float* degrees_true)
	{
		return BVTNavData_GetCourseOverGround( m_ptr, degrees_true );
	}

	/** Store the course over ground, true.
	 * \param degrees_true course over ground, true, in degrees 
	 */
	RetVal SetCourseOverGround(float degrees_true)
	{
		return BVTNavData_SetCourseOverGround( m_ptr, degrees_true );
	}

	/** Returns the speed over ground. If no value was stored for this ping,
	 * returns BVT_NAV_NO_DATA.
	 * \param meters_per_second speed over ground, in meters per second 
	 */
	RetVal GetSpeedOverGround(float* meters_per_second)
	{
		return BVTNavData_GetSpeedOverGround( m_ptr, meters_per_second );
	}

	/** Store the speed over ground.
	 * \param meters_per_second speed over ground, in meters per second 
	 */
	RetVal SetSpeedOverGround(float meters_per_second)
	{
		return BVTNavData_SetSpeedOverGround( m_ptr, meters_per_second );
	}

	/** Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_bow_up pitch angle, in floating point degrees, bow up is positive  
	 */
	RetVal GetPitchAngle(float* degrees_bow_up)
	{
		return BVTNavData_GetPitchAngle( m_ptr, degrees_bow_up );
	}

	/** Store the pitch angle.
	 * \param degrees_bow_up pitch angle, in floating point degrees, bow up is positive  
	 */
	RetVal SetPitchAngle(float degrees_bow_up)
	{
		return BVTNavData_SetPitchAngle( m_ptr, degrees_bow_up );
	}

	/** Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_port_up roll angle, in floating point degrees, port side up is positive  
	 */
	RetVal GetRollAngle(float* degrees_port_up)
	{
		return BVTNavData_GetRollAngle( m_ptr, degrees_port_up );
	}

	/** Store the roll angle.
	 * \param degrees_port_up roll angle, in floating point degrees, port side up is positive  
	 */
	RetVal SetRollAngle(float degrees_port_up)
	{
		return BVTNavData_SetRollAngle( m_ptr, degrees_port_up );
	}

	/** Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 */
	RetVal GetYawAngle(float* degrees_bow_to_starboard)
	{
		return BVTNavData_GetYawAngle( m_ptr, degrees_bow_to_starboard );
	}

	/** Store the yaw angle. <br>
	 * NOTE: This is NOT the same as the Heading field. Heading is for the
	 * normal navigation use of Heading, often from a compass. This field is
	 * intended to store raw data from other research instruments, in case
	 * you need another storage spot. To keep everyone using the fields the
	 * same way so that files can be interchanged, please use SetHeading
	 * for the normal heading, and SetYawAngle() only for special uses.
	 */
	RetVal SetYawAngle(float degrees_bow_to_starboard)
	{
		return BVTNavData_SetYawAngle( m_ptr, degrees_bow_to_starboard );
	}

	/** Returns the rate of pitch change.
	 * If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_per_second rate of pitch change in degrees per second 
	 */
	RetVal GetPitchRate(float* degrees_per_second)
	{
		return BVTNavData_GetPitchRate( m_ptr, degrees_per_second );
	}

	/** Store the the rate of pitch change.
	 * \param degrees_per_second rate of pitch change in degrees per second 
	 */
	RetVal SetPitchRate(float degrees_per_second)
	{
		return BVTNavData_SetPitchRate( m_ptr, degrees_per_second );
	}

	/** Returns the rate of roll change.
	 * If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param degrees_per_second rate of roll change in degrees per second 
	 */
	RetVal GetRollRate(float* degrees_per_second)
	{
		return BVTNavData_GetRollRate( m_ptr, degrees_per_second );
	}

	/** Store the the rate of change in roll.
	 * \param degrees_per_second rate of roll change in floating point degrees per second 
	 */
	RetVal SetRollRate(float degrees_per_second)
	{
		return BVTNavData_SetRollRate( m_ptr, degrees_per_second );
	}

	/** Returns the rate of change in yaw (heading).  If no value was stored for this ping,
	 * returns BVT_NAV_NO_DATA.
	 * \param degrees_per_second rate of yaw change in floating point degrees per second 
	 */
	RetVal GetYawRate(float* degrees_per_second)
	{
		return BVTNavData_GetYawRate( m_ptr, degrees_per_second );
	}

	/** Store the rate of change in yaw (heading).
	 * \param degrees_per_second rate of yaw change in floating point degrees per second 
	 */
	RetVal SetYawRate(float degrees_per_second)
	{
		return BVTNavData_SetYawRate( m_ptr, degrees_per_second );
	}

	/** Gets the stored acceleration along the X axis. If no value was stored for this ping,
	 * returns BVT_NAV_NO_DATA.
	 * \param accel_mg acceleration along X axis, in milli-g 
	 */
	RetVal GetAccelerationX(float* accel_mg)
	{
		return BVTNavData_GetAccelerationX( m_ptr, accel_mg );
	}

	/** Sets the stored acceleration along the X axis. Intended to store
	 * raw values of accelerometers.
	 * \param accel_mg acceleration along X axis, in milli-g 
	 */
	RetVal SetAccelerationX(float accel_mg)
	{
		return BVTNavData_SetAccelerationX( m_ptr, accel_mg );
	}

	/** Gets the stored acceleration along the Y axis. If no value was stored for this ping,
	 * returns BVT_NAV_NO_DATA.
	 * \param accel_mg acceleration along Y axis, in milli-g 
	 */
	RetVal GetAccelerationY(float* accel_mg)
	{
		return BVTNavData_GetAccelerationY( m_ptr, accel_mg );
	}

	/** Sets the stored acceleration along the Y axis. Intended to store
	 * raw values of accelerometers.
	 * \param accel_mg acceleration along Y axis, in milli-g 
	 */
	RetVal SetAccelerationY(float accel_mg)
	{
		return BVTNavData_SetAccelerationY( m_ptr, accel_mg );
	}

	/** Gets the stored acceleration along the Z axis. If no value was stored for this ping,
	 * returns BVT_NAV_NO_DATA.
	 * \param accel_mg acceleration along Z axis, in milli-g 
	 */
	RetVal GetAccelerationZ(float* accel_mg)
	{
		return BVTNavData_GetAccelerationZ( m_ptr, accel_mg );
	}

	/** Sets the stored acceleration along the Z axis. Intended to store
	 * raw values of accelerometers.
	 * \param accel_mg acceleration along Z axis, in milli-g 
	 */
	RetVal SetAccelerationZ(float accel_mg)
	{
		return BVTNavData_SetAccelerationZ( m_ptr, accel_mg );
	}

	/** Returns the offset, to the north, from a user-defined fixed point.
	 * If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param meters offset to the north, in floating point meters 
	 */
	RetVal GetOffsetNorth(double* meters)
	{
		return BVTNavData_GetOffsetNorth( m_ptr, meters );
	}

	/** Store the offset from a user-defined fixed point.
	 * \param meters offset to the north, in floating point meters 
	 */
	RetVal SetOffsetNorth(double meters)
	{
		return BVTNavData_SetOffsetNorth( m_ptr, meters );
	}

	/** Returns the offset, to the east, from a user-defined fixed point.
	 * If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param meters offset to the east, in floating point meters 
	 */
	RetVal GetOffsetEast(double* meters)
	{
		return BVTNavData_GetOffsetEast( m_ptr, meters );
	}

	/** Store the offset from a user-defined fixed point.
	 * \param meters offset to the east, in floating point meters 
	 */
	RetVal SetOffsetEast(double meters)
	{
		return BVTNavData_SetOffsetEast( m_ptr, meters );
	}

	/** Gets a flag value which indicates if the East and North offset values
	 * are from the stored Latitude and Longitude. (see more below...)
	 * If no value was stored for this ping, returns BVT_NAV_NO_DATA.
	 * \param is_true either 1 or 0, to indicate true or false, respectively 
	 */
	RetVal GetOffsetIsFromLatLongFlag(int* is_true)
	{
		return BVTNavData_GetOffsetIsFromLatLongFlag( m_ptr, is_true );
	}

	/** Sets a flag to indicate if the East and North offset values are from
	 * the stored Latitude and Longitude. If so, then software reading the
	 * file will know to adjust appropriately. If from some special location,
	 * perhaps the UserNavString could be used to indicate the reference
	 * point? If nothing is stored, then the value is assumed to be false.
	 * \param is_true either 1 or 0, to indicate true or false, respectively 
	 */
	RetVal SetOffsetIsFromLatLongFlag(int is_true)
	{
		return BVTNavData_SetOffsetIsFromLatLongFlag( m_ptr, is_true );
	}

	/** Returns the stored user string, in null-terminated form. If no
	 * string was stored, returns a null string.
	 */
	std::string GetUserNavString()
	{
		return BVTNavData_GetUserNavString( m_ptr );
	}

	/** Stores a user-defined string related to navigation. It is highly
	 * recommended to store some identifier such that the data is
	 * recognizable as you own. <br>
	 * Examples of possible uses might be to store locations based on 
	 * coordinate systems other than GPS, indicating information about
	 * the use of the north and east offset parameters, additional fields
	 * from a GPS receiver, or any other information which might change
	 * dynamically.
	 * \param string_in string to be stored, null terminated, max length 80 chars 
	 */
	RetVal SetUserNavString(std::string string_in)
	{
		return BVTNavData_SetUserNavString( m_ptr, string_in.c_str() );
	}

	/** Return the ping's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
	 * Pings are timestamped using a standard UNIX time stamp. This is 
	 * a similar value to that returned by the time() C standard library 
	 * function. In fact, the only difference is the addition of fractional seconds.
	 */
	double GetTimestamp()
	{
		return BVTNavData_GetTimestamp( m_ptr );
	}

	/** Set the NavData's internal time stamp.  See GetTimestamp() for more information. 
	 * \param sec Timestamp in seconds since 00:00:00 UTC, January 1, 1970 
	 */
	RetVal SetTimestamp(double sec)
	{
		return BVTNavData_SetTimestamp( m_ptr, sec );
	}


private:
	BVTNavData m_ptr;

	/// Prevent this object from being coppied
	NavData(const NavData&);
	NavData&operator=(const NavData&);
};
}

#endif
